## url에 있는 메소드들
```java
String url = "www.naver.com";

new URL(url).openConnection().getInputStream(); //1
new URL(url).openStream(); //2
```
1. url에 연결하고 inputStream을 가져온다.
2. 위의 기능을 Wrapper Method로 만든 것이다!

1처럼 커넥션을 열고 인풋스트림을 받는게 일상화 되어서 2처럼 래퍼메소드를 만든 것이다.  
하지만 그렇다고 해서 1을 없애면 하위 호환이 되지 않기 때문에 없애지 않았을 뿐이다.
 - URL.openStream() 내부
```java
public final InputStream openStream() throws java.io.IOException {
    return openConnection().getInputStream();
}
```

## DOM과 SAX
-|DOM|SAX
:--:|:-:|:-:
parser|PUSH Parser|Event Parser
표준|표준|비표준
특징|Document 자체를 Tree화 하여<br> 메모리에 한 번에 적재|하나 씩 인식하며 넘어간다.<br>모든 것의 시작 마다 Event를 발생시킨다.
기능|수정, 대체, 입력, 삭제|수정, 삭제 안됨
장점|Tree내용을 한 번에 볼 수 있다.|메모리 적게 먹음.<br>빠름
단점|메모리를 많이 쓴다.<br>파일 로딩이 길다.|저장하지 않고 넘어간 정보는<br>나중에 접근 불가능.

# SAX
> 이벤트 호출 방식의 Parser!

```java
import javax.xml.parsers.*;
import org.xml.sax.helpers.*;
import org.xml.sax.*;

public class SAXTest1 {
    public static void main(String args[]) throws Exception{
        SAXParserFactory fac = SAXParserFactory.newInstance();
        SAXParser perser = fac.newSAXParser();
        SAXHandler handler = new SAXHandler();
        parser.parse(args[0], handler);
    }
}
```
어플리케이션은 parser 이후에 만들어진다.  
Parser에게 interface의 미구현 메소드를 넘겨주고,  
Parser에서 이벤트가 발생하면 handler를 불러서 그 안의 메소드를 실행한다.

```java
public class SAXHandler extends DefaultHandler{
    public void startDocument() {
        System.out.println("-- XML Document 시작");
    }
    public void endDocument() {
        System.out.println("-- XML Document 끝");
    }
    public void startElement(String uri, String localName, String name, Attributes attributes) {
        System.out.println("startElemnet:[" + uri + "]" + "[" + name + "]" + "[" + attributes + "]");
    }
    public void endElement(String uri, String localName, String name) {
        System.out.println("endElemnet:[" + uri + "]" + "[" + localName + "]" + "[" + name + "]");
    }
    public void characters(char[] ch, int start, int length) {
        String str = String.valueOf(ch, start, length);
        System.out.println("characters:" + str);
    }
}
```
> startDocument() - Document의 시작  
endDocument() - Document의 끝  
startElement() - Element의 시작  
endElement() - Element의 끝  
characters() - 태그 안에 있는 content를 읽는다.

속성|설명
:-:|:-:
uri|
localName|
name|태그 이름
attributes|태그 속성들

## characters()
```java
public void characters(char[] ch, int start, int length) {
    System.out.println(start + ", " + length + ":" + new StringBuilder().appenad(ch, start, length));
}
```
이 코드로 아래 xml을 돌리면
```xml
<CheckList>
    <Check code="1001" date="2010.10.01">
        <Clean>H</Clean>
        <Ready>H</Ready>
        <Response>M</Response>
        <Request/>
    </Check>
</CheckList>
```
2 = (개행)(탭)  
3 = (개행)(탭)(탭)  
1 = H  
이런 식으로 나온다!  

# JSON
XML방식은 너무 무겁다... 너무 많은 부가 정보 데이터가 들어있다!  
적은 용량의 **JSON** 방식을 쓰자!

- 단순한 문법
- {"Key":"value"} 방식
- 객체 안에 객체가 또 들어간다.
```json
{
    "person":{  //객체는 중괄호
        "name":"홍길동",
        "age":"21",
        "addr":"역삼동"
    },
    "friends":[ //배열은 대괄호
        "홍삼",
        "홍이",
        "홍일"
    ]
}
```
- Java에서 Json 사용법

코드|방식|설명
:-:|:-:|:-:
JSONObject|객체|key와 value로 이루어졌다.
JSONArray|배열|value로만 이루어져 있다.

## XML과 Json의 차이점
-|XML|Json
:-:|:-:|:-:
데이터 저장|가능|가능
프리젠테이션|가능|가능해지고 있음
주석|가능|불가능
문법체크|가능|불가능
보안성|높음|낮음
복잡성|높음|매우 낮음

## **Gson** - 구글에서 만든 Json
```java
Gson gson = new Gson();

String jsonStr = "~~~~";

Class c = gson.fromJson(jsonStrt, Class.class);
gson.toJson(c);
```
코드|기능
:-|:-:
fromJson()|Json String을 객체로 만든다.
toJson()|객체를 Json String으로 만든다.

> 주의! 여기서 Class는 get, set이 json의 "key"와 이름이 같아야 한다!  
(예) "name":"황하남" => getName(), setName()

## 여담 - 관통 프로젝트
PassProject01



